# 8086实模式
	* 1. 采用\[段地址:偏移地址\]的方式访问内存，最多访问1M的内存空间
		* 段地址左移4位加16位偏移地址，构成20位基地址
		* 基地址 + 偏移地址 = 实地址
	* 2. 段地址:偏移地址:\[0xFFFF:0xFFFF\] 
		* 关于段地址中多余的0xFFF0,我们称之为高端地址区(HMA)，利用内存回卷技术，可以访问这些高地址内存
	* 3. 问题：内存不够用;安全性低：应用程序之间没有界限，可以任意干扰。
	
# 保护模式 (80286以后)
	* 1. 依然兼容实模式
	* 2. 使用段起始地址+偏移地址的方式访问内存地址
	* 3. 为保证安全性，增加了描述符，选择子等方式
		* 每个段增加各种描述，称其为描述符，所有描述符组成一张描述符表
		* 描述符的内存结构：
		| 段基址24-31 | G | D/B | L | AVL | 段界限16-19 | P | DPL | S | TYPE | 段基址16-23 | 高32位
		|				段基址 0-15				|				段界限 0-15				| 低32位
		* 选择子的结构：
			3-15	  2	  0-1
		| 描述索引值 | TI | RPL |
		RPL：请求者特权级标识，判断是否可以访问对应段
		TI： 表示当前选择子所属的描述符表(0-GDT, 1-LDT)
	* 4. 进入保护模式
		* (1) 定义描述符表
		* (2) 打开A20地址线
		* (3) 加载描述符
		* (4) 通知CPU进入保护模式

# 特权级
	* 保护模式特权级(0,1,2,3)
	* CPL(当前代码段特权级)、DPL(内存段特权级)、RPL(选择子特权级)
	* 每个内存段都有固定的特权级(DPL)
	* CPL <= DPL ,方可跳转，处理器不能从高特权级跳转到低特权级
	* 代码段跳转后，CPL改变为跳转目标代码的DPL
	
# 门描述符
	* 调用门(Call Gate)，中断门(Interrupt)，陷阱门(Trap)，任务门(Task)
	|				偏移地址 2				| P | DPL | S | TYPE | 0 | 0 | 0 | Param Count  |	高32位
	|				选择子					|					偏移地址 1					|	低32位
	
# 不同特权级跳转
	* 低特权级 -> 高特权级：
		* 调用门
			* 从TSS段获取高级特权级的目标栈段
			* 将低级特权级栈信息压入高特权级的栈中
	* 高特权级 -> 低特权级：
		* 将低特权级栈信息从高特权级栈中取出并返回到ss和esp：
			* push 指定目标栈段选择子
			* push 栈顶指针位置
			* push 指定目标代码段选择子
			* push 指定目标代码段偏移
			* retf
# 调用门
	* 一般用来向高特权级转移
		* 数值：DPL(目标) <= CPL <= DPL(调用门)
	* 支持同级转移(当作普通函数调用或者接跳转)
	* call 能提升特权级，jump只能同级
	* 从高特权级向低特权级`retf`时，检查段CS.RPL == SS.RPL == SS.RPL,并清空相关段寄存器 
		
		
# 内存分页 (虚拟存储技术)
	* 页是固定大小为4K的内存片，内存管理是基于页为基本单位完成的，将程序逻辑地址和内存物理地址彻底分离
	* 虚拟内存空间(逻辑地址)
		* 程序执行使用(独立于其他程序)
	* 物理内存空间(物理地址)
		* 物理机器所配置的实际内存空间(所有程序共享)
	* (逻辑/物理)地址 = (逻辑/物理) 页号 + 页内偏移
		*地址转换仅变更页号即可，页内偏移不变
	* 页请求/页交换
		* 访问的地址，不在内存中，将目标页从外存加载到内存，更新页表
		* 物理内存不足，选择需要移除的页，将其数据写入外存，更新页表，再进行页请求
		
# 页式内存管理
	* 页框与页面
		* 页框(Frame): 物理内存空间的页(物理页)
		* 页面(Page):  逻辑内存空间的页(逻辑页)
	* 操作系统管理物理内存的方式
		* 页框表(Frame Table): 存储任务的页面内容
		* 任务表(Task Table): 存储任务的状态信息
	* 页表与任务(APP)
		* 页表机制能够保证任务无意外的访问或破坏其他任务的内存
		* 页表是虚拟内存空间与物理内存空间的"分界线"
		* 因为页表的存在，各个任务才具备相同且独立的内存空间
		* 页表是虚拟内存通往物理内存的"唯一通道"
		* 任务 ====> 页表 ====> 物理内存
	* 页交换时替换内存页的方法
		* FIFO页交换算法: 最先进入内存的页先移出
		* LRU算法: 当前使用最少的页从内存中移出
	* 页表
		* 页表本质就是映射表
		* 虚拟内存空间的每一个映射到一个页框
		* 每个任务(App)有页表
		* 单级页表
			* 单级页表大小固定，但是在大多数情况下页表为稀疏状态，会浪费大量内存资源
		* 二级页表
			* 将页号分为两段: 页目录 + 二级页号
			* 若下级页表所有表项为空，那么页目录为空
			* |   0   |  **1**  |  2   |...| 页目录 
			* | NULL  | 页表地址 | NULL |...| 页表地址
			
			* |   0   |    1    | **2** |...| 二级页号 
			* | 0xE0  |   0x10  | 0x31  |...| 页框号
			* 访问虚拟页0x12 ==> 页目录为0x1,二级页号0x2，对应页框号为0x31
