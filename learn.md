# 8086实模式
	* 1. 采用\[段地址:偏移地址\]的方式访问内存，最多访问1M的内存空间
		* 段地址左移4位加16位偏移地址，构成20位基地址
		* 基地址 + 偏移地址 = 实地址
	* 2. 段地址:偏移地址:\[0xFFFF:0xFFFF\] 
		* 关于段地址中多余的0xFFF0,我们称之为高端地址区(HMA)，利用内存回卷技术，可以访问这些高地址内存
	* 3. 问题：内存不够用;安全性低：应用程序之间没有界限，可以任意干扰。
	
# 保护模式 (80286以后)
	* 1. 依然兼容实模式
	* 2. 使用段起始地址+偏移地址的方式访问内存地址
	* 3. 为保证安全性，增加了描述符，选择子等方式
		* 每个段增加各种描述，称其为描述符，所有描述符组成一张描述符表
		* 描述符的内存结构：
		| 段基址24-31 | G | D/B | L | AVL | 段界限16-19 | P | DPL | S | TYPE | 段基址16-23 | 高32位
		|				段基址 0-15				|				段界限 0-15				| 低32位
		* 选择子的结构：
			3-15	  2	  0-1
		| 描述索引值 | TI | RPL |
		RPL：请求者特权级标识，判断是否可以访问对应段
		TI： 表示当前选择子所属的描述符表(0-GDT, 1-LDT)
	* 4. 进入保护模式
		* (1) 定义描述符表
		* (2) 打开A20地址线
		* (3) 加载描述符
		* (4) 通知CPU进入保护模式

# 特权级
	* 保护模式特权级(0,1,2,3)
	* CPL(当前代码段特权级)、DPL(内存段特权级)、RPL(选择子特权级)
	* 每个内存段都有固定的特权级(DPL)
	* CPL <= DPL ,方可跳转，处理器不能从高特权级跳转到低特权级
	* 代码段跳转后，CPL改变为跳转目标代码的DPL
	
# 门描述符
	* 调用门(Call Gate)，中断门(Interrupt)，陷阱门(Trap)，任务门(Task)
	|				偏移地址 2				| P | DPL | S | TYPE | 0 | 0 | 0 | Param Count  |	高32位
	|				选择子					|					偏移地址 1					|	低32位
	
	
	
	
	
	
	
