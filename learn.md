# 8086实模式
	* 1. 采用\[段地址:偏移地址\]的方式访问内存，最多访问1M的内存空间
		* 段地址左移4位加16位偏移地址，构成20位基地址
		* 基地址 + 偏移地址 = 实地址
	* 2. 段地址:偏移地址:\[0xFFFF:0xFFFF\] 
		* 关于段地址中多余的0xFFF0,我们称之为高端地址区(HMA)，利用内存回卷技术，可以访问这些高地址内存
	* 3. 问题：内存不够用;安全性低：应用程序之间没有界限，可以任意干扰。
	
# 保护模式 (80286以后)
	* 1. 依然兼容实模式
	* 2. 使用段起始地址+偏移地址的方式访问内存地址
	* 3. 为保证安全性，增加了描述符，选择子等方式
		* 每个段增加各种描述，称其为描述符，所有描述符组成一张描述符表
		* 描述符的内存结构：
		| 段基址24-31 | G | D/B | L | AVL | 段界限16-19 | P | DPL | S | TYPE | 段基址16-23 | 高32位
		|				段基址 0-15				|				段界限 0-15				| 低32位
		* 选择子的结构：
			3-15	  2	  0-1
		| 描述索引值 | TI | RPL |
		RPL：请求者特权级标识，判断是否可以访问对应段
		TI： 表示当前选择子所属的描述符表(0-GDT, 1-LDT)
	* 4. 进入保护模式
		* (1) 定义描述符表
		* (2) 打开A20地址线
		* (3) 加载描述符
		* (4) 通知CPU进入保护模式

# 特权级
	* 保护模式特权级(0,1,2,3)
	* CPL(当前代码段特权级)、DPL(内存段特权级)、RPL(选择子特权级)
	* 每个内存段都有固定的特权级(DPL)
	* CPL <= DPL ,方可跳转，处理器不能从高特权级跳转到低特权级
	* 代码段跳转后，CPL改变为跳转目标代码的DPL
	
# 门描述符
	* 调用门(Call Gate)，中断门(Interrupt)，陷阱门(Trap)，任务门(Task)
	|				偏移地址 2				| P | DPL | S | TYPE | 0 | 0 | 0 | Param Count  |	高32位
	|				选择子					|					偏移地址 1					|	低32位
	
# 不同特权级跳转
	* 低特权级 -> 高特权级：
		* 调用门
			* 从TSS段获取高级特权级的目标栈段
			* 将低级特权级栈信息压入高特权级的栈中
	* 高特权级 -> 低特权级：
		* 将低特权级栈信息从高特权级栈中取出并返回到ss和esp：
			* push 指定目标栈段选择子
			* push 栈顶指针位置
			* push 指定目标代码段选择子
			* push 指定目标代码段偏移
			* retf
# 调用门
	* 一般用来向高特权级转移
		* 数值：DPL(目标) <= CPL <= DPL(调用门)
	* 支持同级转移(当作普通函数调用或者接跳转)
	* call 能提升特权级，jump只能同级
	* 从高特权级向低特权级`retf`时，检查段CS.RPL == SS.RPL == SS.RPL,并清空相关段寄存器 
		
		
		
		
		
		
		
	
